#!/usr/bin/env ts-node

import chalk from 'chalk';
import { readFile, writeFile } from 'fs/promises';
import glob from 'glob-promise';
import { join } from 'path';
import spaceTrim from 'spacetrim';
//import nodegit from 'nodegit';
import { PackageJson, Promisable } from 'type-fest';
import { WORKFLOWS } from './config';
import { execCommand } from './utils/execCommand/execCommand';
import { findAllProjects } from './utils/findAllProjects';
import { findProjectName } from './utils/findProjectName';
import { isWorkingTreeClean } from './utils/isWorkingTreeClean';

export async function workflows() {
    const changedProjects: string[] = [];

    // console.log(await findAllProjects());
    // await forEver();

    for (const projectPath of await findAllProjects()) {
        for (const workflow of WORKFLOWS) {
            const projectName = await findProjectName(projectPath);

            const currentBranch = await execCommand({
                command: 'git branch --show-current',
                cwd: projectPath,
            });

            if (currentBranch !== 'main' && currentBranch !== 'master') {
                console.info(
                    `‚è© Skipping project ${projectName} because current branch is not main (or master) but ${currentBranch}`,
                );
                continue;
            }

            if (!(await isWorkingTreeClean(projectPath))) {
                console.info(chalk.gray(`‚è© Skipping project ${projectName} because working dir is not clean`));
                continue;
            }

            console.info(`üîº Running workflow ${workflow.name} for project ${projectName}`);

            await execCommand({
                command: 'git pull',
                crashOnError: false,
                cwd: projectPath,
            });

            async function modifyFiles(
                globPattern: string,
                fileModifier: (fileContent: string) => Promisable<string>,
            ): Promise<void> {
                for (const filePath of await glob(join(projectPath, globPattern), {
                    dot: true,
                    ignore: ['**/node_modules/**', '**/.git/**'],
                })) {
                    const fileContent = await readFile(filePath, 'utf8');
                    const newFileContent = await fileModifier(fileContent);

                    if (fileContent !== newFileContent) {
                        console.info(`üíæ Changing file ${filePath}`);
                        await writeFile(filePath, newFileContent);
                    } else {
                        // console.info(`‚¨ú Keeping file ${filePath}`);
                    }
                }
            }

            const packageJson = JSON.parse(await readFile(join(projectPath, 'package.json'), 'utf8'));
            function modifyPackage(
                fileModifier: (packageContent: PackageJson) => Promisable<PackageJson>,
            ): Promise<void> {
                return modifyFiles(
                    'package.json',
                    async (fileContent) => JSON.stringify(fileModifier(JSON.parse(fileContent)), null, 2) + '\n',
                );
            }

            // TODO: !!! Rename to execCommand
            function runCommand(command: string) {
                return execCommand({
                    command,
                    cwd: projectPath,
                });
            }

            let isCommitted = false;
            async function commit(message: string): Promise<void> {
                if (await isWorkingTreeClean(projectPath)) {
                    console.info(chalk.gray(`‚è© Not commiting because nothings changed`));
                    return;
                }

                await execCommand({
                    cwd: projectPath,
                    crashOnError: false,
                    command: `git add .`,
                });

                const commitMessageFilePath = join(process.cwd(), '.tmp', 'COMMIT_MESSAGE');
                const commitMessage = spaceTrim(
                    (block) => `
                      ${block(message)}

                      üîº This commit was automatically generated by [Batch project editor](https://github.com/hejny/batch-project-editor)
                    `,
                );

                await writeFile(commitMessageFilePath, commitMessage, 'utf8');

                await execCommand({
                    cwd: projectPath,
                    command: `git commit --file ${commitMessageFilePath}`,
                });

                await execCommand({
                    cwd: projectPath,
                    crashOnError: false,
                    command: `git push --quiet`,
                });

                isCommitted = true;
            }

            await workflow({
                projectPath,
                projectName,
                packageJson,
                runCommand,
                modifyFiles,
                modifyPackage,
                commit,
            });

            if (!(await isWorkingTreeClean(projectPath))) {
                console.info(
                    chalk.red(
                        `‚ùó Workflow ${workflow.name} for the project ${projectName} ended with dirty working dir`,
                    ),
                );
                process.exit();
            }

            if (isCommitted) {
                changedProjects.push(projectPath);
            }
        }
    }

    console.info(chalk.bgGreen(`Changed ${changedProjects.length} projects:`));

    for (const projectPath of changedProjects) {
        // TODO: !!!  Do not show here system path but GitHub URL
        console.info(chalk.bgGreen(projectPath));
    }
}
