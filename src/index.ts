#!/usr/bin/env ts-node

import chalk from 'chalk';
import { readFile, writeFile } from 'fs/promises';
import glob from 'glob-promise';
import { join } from 'path';
import spaceTrim from 'spacetrim';
//import nodegit from 'nodegit';
import { PackageJson, Promisable } from 'type-fest';
import { WORKFLOWS } from './config';
import { execCommand } from './utils/execCommand/execCommand';
import { findAllProjects } from './utils/findAllProjects';
import { findProjectName } from './utils/findProjectName';
import { isWorkingTreeClean } from './utils/isWorkingTreeClean';

// TODO: Recieve flags
main();

async function main() {
    for (const projectPath of await findAllProjects()) {
        for (const workflow of WORKFLOWS) {
            const projectName = await findProjectName(projectPath);

            const currentBranch = await execCommand({
                command: 'git branch --show-current',
                cwd: projectPath,
            });

            if (currentBranch !== 'main' && currentBranch !== 'master') {
                console.info(
                    `â© Skipping project ${projectName} because current branch is not main (or master) but ${currentBranch}`,
                );
                continue;
            }

            if (!(await isWorkingTreeClean(projectPath))) {
                console.info(chalk.gray(`â© Skipping project ${projectName} because working dir is not clean`));
                continue;
            }

            console.info(`ðŸ”¼ Running workflow ${workflow.name} for project ${projectName}`);

            await execCommand({
                command: 'git pull',
                cwd: projectPath,
            });

            async function modifyFiles(
                globPattern: string,
                fileModifier: (fileContent: string) => Promisable<string>,
            ): Promise<void> {
                for (const filePath of await glob(join(projectPath, globPattern), {
                    dot: true,
                    ignore: ['**/node_modules/**', '**/.git/**'],
                })) {
                    const fileContent = await readFile(filePath, 'utf8');
                    const newFileContent = await fileModifier(fileContent);

                    if (fileContent !== newFileContent) {
                        console.info(`ðŸ’¾ Changing file ${filePath}`);
                        await writeFile(filePath, newFileContent);
                    } else {
                        // console.info(`â¬œ Keeping file ${filePath}`);
                    }
                }
            }

            const packageJson = JSON.parse(await readFile(join(projectPath, 'package.json'), 'utf8'));
            function modifyPackage(
                fileModifier: (packageContent: PackageJson) => Promisable<PackageJson>,
            ): Promise<void> {
                return modifyFiles('package.json', async (fileContent) =>
                    JSON.stringify(fileModifier(JSON.parse(fileContent)), null, 2),
                );
            }

            // TODO: !!! Rename to execCommand
            function runCommand(command: string) {
                return execCommand({
                    command,
                    cwd: projectPath,
                });
            }

            async function commit(message: string): Promise<void> {
                if (await isWorkingTreeClean(projectPath)) {
                    console.info(chalk.gray(`â© Not commiting because nothings changed`));
                    return;
                }

                await execCommand({
                    cwd: projectPath,
                    crashOnError: false,
                    command: `git add .`,
                });

                const commitMessageFilePath = join(process.cwd(), '.tmp', 'COMMIT_MESSAGE');
                const commitMessage = spaceTrim(
                    (block) => `
                      ${block(message)}

                      ðŸ”¼ This commit was automatically generated by [Batch project editor](https://github.com/hejny/batch-project-editor)
                    `,
                );

                await writeFile(commitMessageFilePath, commitMessage, 'utf8');

                await execCommand({
                    cwd: projectPath,
                    command: `git commit --file ${commitMessageFilePath}`,
                });

                await execCommand({
                    cwd: projectPath,
                    crashOnError: false,
                    command: `git push --quiet`,
                });
            }

            await workflow({
                projectPath,
                projectName,
                packageJson,
                runCommand,
                modifyFiles,
                modifyPackage,
                commit,
            });
        }
    }
}
